{# report_maker/templates/report_maker/image_form.html #}
{% extends 'report_maker/base_report_maker.html' %}
{% load static %}

{% block title %}
  {% if object %}
    Editar imagem
  {% else %}
    Adicionar imagem
  {% endif %}
{% endblock %}

{% block page_header %}
  {% include 'headerbars/report_maker.html' %}
{% endblock %}

{% block report_maker_content %}
  <div class="container mt-4" style="max-width: 980px;">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h4 class="mb-0">
        {% if object %}
          Editar imagem
        {% else %}
          Adicionar imagem
        {% endif %}
      </h4>
    </div>

    <form method="post" enctype="multipart/form-data" id="image-form" novalidate>
      {% csrf_token %}
      <input type="hidden" name="width_override" id="id_width_override">
      <input type="hidden" name="next" value="{{ request.GET.next }}" />

      <div class="image-editor card shadow-sm" data-editor data-mode="{{ mode|default:'create' }}" data-initial-image-url="{{ initial_image_url|default:'' }}">
        <div class="card-header py-2">
          <div class="d-flex flex-wrap align-items-center gap-3">
            {# Grupo: Arquivo e Rotação #}
            <div class="btn-group btn-group-sm">
              <button id="btn-upload-trigger" type="button" class="btn btn-outline-secondary" title="Selecionar imagem"><i class="bi bi-folder2-open"></i></button>
              <button id="btn-rotate" type="button" class="btn btn-outline-secondary" title="Rotacionar 90°" disabled><i class="bi bi-arrow-clockwise"></i></button>
            </div>

            {# Grupo: Zoom #}
            <div class="btn-group btn-group-sm" role="group">
              <button id="btn-zoom-out" type="button" class="btn btn-outline-secondary" title="Zoom -" disabled><i class="bi bi-zoom-out"></i></button>
              <button id="btn-zoom-reset" type="button" class="btn btn-outline-secondary" title="Reset zoom" disabled><i class="bi bi-aspect-ratio"></i></button>
              <button id="btn-zoom-in" type="button" class="btn btn-outline-secondary" title="Zoom +" disabled><i class="bi bi-zoom-in"></i></button>
            </div>

            {# Grupo: Ajustes de Imagem #}
            <div class="d-flex align-items-center gap-2 border-start ps-3">
              <label class="small text-muted" title="Brilho"><i class="bi bi-brightness-high"></i></label>
              <input type="range" id="input-brightness" class="form-range" min="0" max="200" value="100" style="width: 80px;" disabled />

              <label class="small text-muted ms-2" title="Contraste"><i class="bi bi-circle-half"></i></label>
              <input type="range" id="input-contrast" class="form-range" min="0" max="200" value="100" style="width: 80px;" disabled />
            </div>

            {# Grupo: Ajuste nas dimenões do canvas, afeta tamanho real da imagem #}
            <div class="d-flex align-items-center gap-2 border-start ps-3">
              <label class="small text-muted">Largura (cm):</label>
              <select id="select-width-cm" class="form-select form-select-sm" style="width: 70px;">
                <option value="14">14</option>
                <option value="12">12</option>
                <option value="10">10</option>
                <option value="8">8</option>
                <option value="6">6</option>
                <option value="4">4</option>
              </select>
            </div>

            {# Grupo: Reset Geral #}
            <div class="btn-group btn-group-sm ms-auto">
              <button id="btn-reset-editor" type="button" class="btn btn-outline-secondary" disabled title="Resetar tudo"><i class="bi bi-arrow-repeat"></i></button>
            </div>
          </div>
        </div>

        <div class="card-body">
          {# Input oculto do Django #}
          <div class="mb-3 d-none" data-file-row>{{ form.image }}</div>

          <div class="mx-auto" data-stage-wrap style="max-width: 800px; width: 100%;">
            {# Régua pericial #}
            {% include 'report_maker/partials/scale14.html' %}

            <div class="border rounded-3 bg-body-tertiary" data-stage style="overflow:hidden; margin:0 auto; min-height: 250px; display: flex; align-items: center; justify-content: center;">
              <canvas id="main-canvas" style="display: block; max-width: 100%; height: auto;"></canvas>
            </div>

            <div class="mt-4 w-100" data-caption-wrap>
              {% with field=form.caption %}
                {% include 'report_maker/partials/text_block_editor.html' with field_name=field.name label=field.label value=field.value help_text=field.help_text rows=8 %}
              {% endwith %}
            </div>
          </div>
        </div>

        <div class="card-footer d-flex gap-2 justify-content-end">
          <a href="{{ cancel_url }}" class="btn btn-outline-secondary btn-sm">Cancelar</a>
          <button type="submit" class="btn btn-primary btn-sm"><i class="bi bi-check-lg"></i> Salvar</button>
        </div>
      </div>
    </form>
  </div>
{% endblock %}

{% block scripts %}
  {{ block.super }}
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const form = document.getElementById('image-form')
      const btnTrigger = document.getElementById('btn-upload-trigger')
      const btnRotate = document.getElementById('btn-rotate')
      const btnReset = document.getElementById('btn-reset-editor')
      const selectWidth = document.getElementById('select-width-cm')
    
      const btnZoomIn = document.getElementById('btn-zoom-in')
      const btnZoomOut = document.getElementById('btn-zoom-out')
      const btnZoomReset = document.getElementById('btn-zoom-reset')
    
      const fileInput = document.getElementById('id_image')
      const canvas = document.getElementById('main-canvas')
      const ctx = canvas.getContext('2d')
      const editorEl = document.querySelector('[data-editor]')
    
      const sliderBrightness = document.getElementById('input-brightness')
      const sliderContrast = document.getElementById('input-contrast')
    
      // Constante de densidade: 14cm = 1600px -> ~114.28 px/cm
      const PX_PER_CM = 1600 / 14
      let imagemOriginal = null
    
      // Estados
      let currentRotation = 0
      let currentZoom = 1.0
      let offsetX = 0
      let offsetY = 0
      let isDragging = false
      let startX, startY
    
      function getTargetPx() {
        return parseFloat(selectWidth.value) * PX_PER_CM
      }
    
      function getClosestWidthCm(pixelWidth) {
        // Nossos pontos de parada em pixels (cm * 114.2857)
        const targets = [
          { cm: 4, px: 457 },
          { cm: 10, px: 1143 },
          { cm: 14, px: 1600 }
        ]
    
        // Encontra o alvo cuja diferença de pixels seja a menor
        const closest = targets.reduce((prev, curr) => {
          return Math.abs(curr.px - pixelWidth) < Math.abs(prev.px - pixelWidth) ? curr : prev
        })
    
        return closest.cm
      }
    
      function applyConstraints() {
        if (!imagemOriginal) return
    
        const targetWidthPx = getTargetPx()
        const isVertical = (currentRotation / 90) % 2 !== 0
    
        // Dimensões lógicas da imagem após a rotação ser aplicada
        let logicalW = isVertical ? imagemOriginal.height : imagemOriginal.width
        let logicalH = isVertical ? imagemOriginal.width : imagemOriginal.height
    
        // Escala base para que a largura lógica preencha a largura do canvas (CM selecionados)
        let baseScale = targetWidthPx / logicalW
    
        let imgW = logicalW * baseScale * currentZoom
        let imgH = logicalH * baseScale * currentZoom
    
        // 1. Bloqueia zoom que deixe espaços vazios nas laterais do canvas
        if (imgW < canvas.width) {
          currentZoom = canvas.width / (logicalW * baseScale)
          imgW = canvas.width
        }
    
        // 2. Bloqueia o Pan (arrasto) para não mostrar o fundo do canvas
        const maxOffsetX = Math.max(0, (imgW - canvas.width) / 2)
        const maxOffsetY = Math.max(0, (imgH - canvas.height) / 2)
    
        offsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, offsetX))
        offsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, offsetY))
      }
    
      function renderImageToCanvas(img) {
        if (!img) return
        imagemOriginal = img
    
        const targetWidthPx = getTargetPx()
        const isVertical = (currentRotation / 90) % 2 !== 0
    
        // Ativa controles
        ;[btnRotate, btnReset, btnZoomIn, btnZoomOut, btnZoomReset, sliderBrightness, sliderContrast].forEach((el) => (el.disabled = false))
    
        // DIMENSÕES DINÂMICAS: Recalcula a altura do canvas baseada na rotação
        let logicalW = isVertical ? img.height : img.width
        let logicalH = isVertical ? img.width : img.height
    
        // O Canvas assume a largura proporcional aos CM e altura proporcional à imagem rotacionada
        canvas.width = targetWidthPx
        canvas.height = logicalH * (targetWidthPx / logicalW)
    
        // Ajusta o tamanho do container no ecrã (proporção visual)
        canvas.parentElement.style.width = targetWidthPx / 2 + 'px'
    
        // --- FUNDO BRANCO ---
        // Pintamos o fundo de branco antes de qualquer coisa para evitar transparências pretas
        ctx.save()
        ctx.fillStyle = '#ffffff'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        ctx.restore()
    
        applyConstraints()
    
        ctx.save()
    
        // Aplica os filtros de imagem
        ctx.filter = `brightness(${sliderBrightness.value}%) contrast(${sliderContrast.value}%)`
    
        // Aplica Pan e Rotação no centro
        ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY)
        ctx.rotate((currentRotation * Math.PI) / 180)
        ctx.scale(currentZoom, currentZoom)
    
        // A escala de desenho usa as dimensões ORIGINAIS da imagem
        const drawScale = targetWidthPx / logicalW
    
        // Desenha a imagem centralizada
        ctx.drawImage(img, (-img.width * drawScale) / 2, (-img.height * drawScale) / 2, img.width * drawScale, img.height * drawScale)
    
        ctx.restore()
    
        canvas.style.cursor = currentZoom > 1.01 ? 'grab' : 'default'
      }
    
      // --- Listeners de Largura e Pan ---
      selectWidth.addEventListener('change', () => {
        // Resetamos zoom e pan ao mudar a largura para evitar erros de cálculo
        currentZoom = 1.0
        offsetX = 0
        offsetY = 0
        renderImageToCanvas(imagemOriginal)
      })
    
      canvas.addEventListener('mousedown', (e) => {
        if (currentZoom <= 1.01) return
        isDragging = true
        canvas.style.cursor = 'grabbing'
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        startX = e.clientX * scaleX - offsetX
        startY = e.clientY * scaleY - offsetY
      })
    
      window.addEventListener('mousemove', (e) => {
        if (!isDragging) return
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        offsetX = e.clientX * scaleX - startX
        offsetY = e.clientY * scaleY - startY
        renderImageToCanvas(imagemOriginal)
      })
    
      window.addEventListener('mouseup', () => {
        isDragging = false
      })
    
      // --- Botões de Zoom ---
      btnZoomIn.addEventListener('click', () => {
        currentZoom += 0.2
        renderImageToCanvas(imagemOriginal)
      })
      btnZoomOut.addEventListener('click', () => {
        currentZoom -= 0.2
        renderImageToCanvas(imagemOriginal)
      })
      btnZoomReset.addEventListener('click', () => {
        currentZoom = 1.0
        offsetX = 0
        offsetY = 0
        renderImageToCanvas(imagemOriginal)
      })
    
      // --- Rotação e Filtros ---
      btnRotate.addEventListener('click', () => {
        currentRotation = (currentRotation + 90) % 360
        currentZoom = 1.0
        offsetX = 0
        offsetY = 0
        renderImageToCanvas(imagemOriginal)
      })
      ;[sliderBrightness, sliderContrast].forEach((s) => {
        s.addEventListener('input', () => renderImageToCanvas(imagemOriginal))
      })
    
      btnTrigger.addEventListener('click', () => fileInput.click())
    
      btnReset.addEventListener('click', function () {
        if (imagemOriginal && confirm('Descartar tudo?')) {
          currentRotation = 0
          currentZoom = 1.0
          offsetX = 0
          offsetY = 0
          selectWidth.value = '14'
          sliderBrightness.value = 100
          sliderContrast.value = 100
          renderImageToCanvas(imagemOriginal)
        }
      })
    
      fileInput.addEventListener('change', function (e) {
        const file = e.target.files[0]
        if (!file) return
        const reader = new FileReader()
        reader.onload = (ev) => {
          const img = new Image()
          img.onload = () => {
            currentRotation = 0
            offsetX = 0
            offsetY = 0
    
            // 1. Descobrimos qual o melhor tamanho em CM para essa imagem
            const suggestedCm = getClosestWidthCm(img.width)
    
            // 2. Atualizamos o SELECT de largura para o usuário ver
            selectWidth.value = suggestedCm.toString()
    
            // 3. Disparamos a função que você já tem que ajusta o Canvas
            // (Presumindo que sua função se chame ajustarTamanhoCanvas ou similar)
            // Se não tiver uma função separada, aplique a lógica de redimensionar o canvas.width aqui
            const novoWidthPx = Math.round(suggestedCm * 114.2857)
            canvas.width = novoWidthPx
    
            // Opcional: ajustar a altura proporcionalmente ou manter fixa
            // canvas.height = (img.height / img.width) * novoWidthPx;
    
            // 4. Forçamos o Zoom a ser 1.0 para que ela preencha o canvas novo exatamente
            currentZoom = canvas.width / img.width
    
            renderImageToCanvas(img)
          }
          img.src = ev.target.result
        }
        reader.readAsDataURL(file)
      })
    
      // 1. Carregamento inicial da imagem (Modo Edição)
      const initialUrl = editorEl.dataset.initialImageUrl
      if (initialUrl) {
        const img = new Image()
        img.crossOrigin = 'anonymous'
        img.onload = () => {
          // Tenta recuperar a largura salva no banco de dados para setar o selectWidth
          {% if object and object.original_width %}
            const savedPx = {{ object.original_width }}
            // Converte pixels de volta para o valor aproximado da régua (4, 10 ou 14)
            const targetCm = Math.round(savedPx / 114.2857)
            
            // Se o valor calculado bater com nossas opções, define no select
            if ([4, 10, 14].includes(targetCm)) {
              selectWidth.value = targetCm.toString()
            }
          {% endif %}

          // Reseta estados para garantir que a edição comece limpa
          currentRotation = 0
          currentZoom = 1.0
          offsetX = 0
          offsetY = 0
          
          renderImageToCanvas(img)
        }
        img.src = initialUrl
      }
    
      // 2. Envio do formulário (Processamento do Canvas para Blob)
      form.addEventListener('submit', function (e) {
        if (!imagemOriginal) return
        e.preventDefault()


        document.getElementById('id_width_override').value = getTargetPx();
        // O fundo branco já foi garantido na função renderImageToCanvas
        canvas.toBlob(
          (blob) => {
            // Criamos o arquivo JPEG. O fundo branco preencherá qualquer transparência original.
            const file = new File([blob], 'pericia_final.jpg', { type: 'image/jpeg' })
            const dataTransfer = new DataTransfer()
            dataTransfer.items.add(file)
            fileInput.files = dataTransfer.files
            
            // Envia o formulário de fato
            form.submit()
          },
          'image/jpeg',
          0.92 // Qualidade preservando detalhes periciais
        )
      })
    })
  </script>
{% endblock %}
