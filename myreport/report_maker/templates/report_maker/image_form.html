{# report_maker/templates/report_maker/image_form.html #}
{% extends 'report_maker/base_report_maker.html' %}
{% load static %}

{% block title %}
  {% if object %}
    Editar imagem
  {% else %}
    Adicionar imagem
  {% endif %}
{% endblock %}

{% block page_header %}
  {% include 'headerbars/report_maker.html' %}
{% endblock %}

{% block report_maker_content %}
  <div class="container mt-4" style="max-width: 980px;">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h4 class="mb-0">
        {% if object %}
          Editar imagem
        {% else %}
          Adicionar imagem
        {% endif %}
      </h4>
    </div>

    <form method="post" enctype="multipart/form-data" id="image-form" novalidate>
      {% csrf_token %}
      <input type="hidden" name="width_override" id="id_width_override" />
      <input type="hidden" name="next" value="{{ request.GET.next }}" />

      <div class="image-editor card shadow-sm" data-editor data-mode="{{ mode|default:'create' }}" data-initial-image-url="{{ initial_image_url|default:'' }}">
        <div class="card-header py-2">
          <div class="d-flex flex-wrap align-items-center gap-3">
            {# Grupo: Arquivo e Rotação #}
            <div class="btn-group btn-group-sm">
              <button id="btn-upload-trigger" type="button" class="btn btn-outline-secondary" title="Selecionar imagem"><i class="bi bi-folder2-open"></i></button>
              <button id="btn-rotate" type="button" class="btn btn-outline-secondary" title="Rotacionar 90°" disabled><i class="bi bi-arrow-clockwise"></i></button>
            </div>

            {# Grupo: Zoom #}
            <div class="btn-group btn-group-sm" role="group">
              <button id="btn-zoom-out" type="button" class="btn btn-outline-secondary" title="Zoom -" disabled><i class="bi bi-zoom-out"></i></button>
              <button id="btn-zoom-reset" type="button" class="btn btn-outline-secondary" title="Reset zoom" disabled><i class="bi bi-aspect-ratio"></i></button>
              <button id="btn-zoom-in" type="button" class="btn btn-outline-secondary" title="Zoom +" disabled><i class="bi bi-zoom-in"></i></button>
              <button id="btn-crop" type="button" class="btn btn-outline-secondary" title="Recortar" disabled><i class="bi bi-crop"></i></button>
              <button id="btn-arrow" type="button" class="btn btn-outline-secondary" title="Seta" disabled><i class="bi bi-arrow-up-right"></i></button>

              <!-- Paleta simples (pode ficar ao lado do botão seta) -->
              <select id="select-arrow-color" class="form-select form-select-sm" style="width: 110px;" disabled title="Cor da seta">
                <option value="#111111">Preto</option>
                <option value="#d32f2f">Vermelho</option>
                <option value="#1976d2">Azul</option>
                <option value="#2e7d32">Verde</option>
                <option value="#f9a825">Amarelo</option>
                <option value="#ffffff">Branco</option>
              </select>
            </div>

            {# Grupo: Ajustes de Imagem #}
            <div class="d-flex align-items-center gap-2 border-start ps-3">
              <label class="small text-muted" title="Brilho"><i class="bi bi-brightness-high"></i></label>
              <input type="range" id="input-brightness" class="form-range" min="0" max="200" value="100" style="width: 80px;" disabled />

              <label class="small text-muted ms-2" title="Contraste"><i class="bi bi-circle-half"></i></label>
              <input type="range" id="input-contrast" class="form-range" min="0" max="200" value="100" style="width: 80px;" disabled />
            </div>

            {# Grupo: Ajuste nas dimenões do canvas, afeta tamanho real da imagem #}
            <div class="d-flex align-items-center gap-2 border-start ps-3">
              <label class="small text-muted">Largura (cm):</label>
              <select id="select-width-cm" class="form-select form-select-sm" style="width: 70px;">
                <option value="14">14</option>
                <option value="12">12</option>
                <option value="10">10</option>
                <option value="8">8</option>
                <option value="6">6</option>
                <option value="4">4</option>
              </select>
            </div>

            {# Grupo: Reset Geral #}
            <div class="btn-group btn-group-sm ms-auto">
              <button id="btn-reset-editor" type="button" class="btn btn-outline-secondary" disabled title="Resetar tudo"><i class="bi bi-arrow-repeat"></i></button>
            </div>
          </div>
        </div>

        <div class="card-body">
          {# Input oculto do Django #}
          <div class="mb-3 d-none" data-file-row>{{ form.image }}</div>

          <div class="mx-auto" data-stage-wrap style="max-width: 800px; width: 100%;">
            {# Régua pericial #}
            {% include 'report_maker/partials/scale14.html' %}

            <div class="border rounded-3 bg-body-tertiary" data-stage style="overflow:hidden; margin:0 auto; min-height: 250px; display: flex; align-items: center; justify-content: center;">
              <canvas id="main-canvas" style="display: block; max-width: 100%; height: auto;"></canvas>
            </div>

            <div class="mt-4 w-100" data-caption-wrap>
              {% with field=form.caption %}
                {% include 'report_maker/partials/text_block_editor.html' with field_name=field.name label=field.label value=field.value help_text=field.help_text rows=8 %}
              {% endwith %}
            </div>
          </div>
        </div>

        <div class="card-footer d-flex gap-2 justify-content-end">
          <a href="{{ cancel_url }}" class="btn btn-outline-secondary btn-sm">Cancelar</a>
          <button type="submit" class="btn btn-primary btn-sm"><i class="bi bi-check-lg"></i> Salvar</button>
        </div>
      </div>
    </form>
  </div>
{% endblock %}

{% block scripts %}
  {{ block.super }}
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const form = document.getElementById('image-form')
      const btnTrigger = document.getElementById('btn-upload-trigger')
      const btnRotate = document.getElementById('btn-rotate')
      const btnReset = document.getElementById('btn-reset-editor')
      const btnCrop = document.getElementById('btn-crop')
      const btnArrow = document.getElementById('btn-arrow')
      const selectArrowColor = document.getElementById('select-arrow-color')
      const selectWidth = document.getElementById('select-width-cm')

      const btnZoomIn = document.getElementById('btn-zoom-in')
      const btnZoomOut = document.getElementById('btn-zoom-out')
      const btnZoomReset = document.getElementById('btn-zoom-reset')

      const fileInput = document.getElementById('id_image')
      const canvas = document.getElementById('main-canvas')
      const ctx = canvas.getContext('2d')
      const editorEl = document.querySelector('[data-editor]')

      const sliderBrightness = document.getElementById('input-brightness')
      const sliderContrast = document.getElementById('input-contrast')

      // Constante de densidade: 14cm = 1600px -> ~114.28 px/cm
      const PX_PER_CM = 1600 / 14
      let imagemOriginal = null

      // Estados
      let currentRotation = 0
      let currentZoom = 1.0
      let offsetX = 0
      let offsetY = 0
      let isDragging = false
      let startX, startY

      // Ferramentas
      let tool = 'none' // 'none' | 'crop' | 'arrow'

      // Estados do crop
      let cropDragging = false
      let cropStartX = 0
      let cropStartY = 0
      let cropRect = null // { x, y, w, h }

      // Estados da seta
      let arrowDragging = false
      let arrowStart = null // {x,y}
      let arrowEnd = null   // {x,y}

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v))
      }

      function canvasPointFromMouseEvent(e) {
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        const x = (e.clientX - rect.left) * scaleX
        const y = (e.clientY - rect.top) * scaleY
        return { x, y }
      }

      function getTargetPx() {
        return parseFloat(selectWidth.value) * PX_PER_CM
      }

      function getClosestWidthCm(pixelWidth) {
        // Nossos pontos de parada em pixels (cm * 114.2857)
        const targets = [
          { cm: 4, px: 457 },
          { cm: 10, px: 1143 },
          { cm: 14, px: 1600 }
        ]

        // Encontra o alvo cuja diferença de pixels seja a menor
        const closest = targets.reduce((prev, curr) => {
          return Math.abs(curr.px - pixelWidth) < Math.abs(prev.px - pixelWidth) ? curr : prev
        })

        return closest.cm
      }

      function applyConstraints() {
        if (!imagemOriginal) return

        const targetWidthPx = getTargetPx()
        const isVertical = (currentRotation / 90) % 2 !== 0

        // Dimensões lógicas da imagem após a rotação ser aplicada
        let logicalW = isVertical ? imagemOriginal.height : imagemOriginal.width
        let logicalH = isVertical ? imagemOriginal.width : imagemOriginal.height

        // Escala base para que a largura lógica preencha a largura do canvas (CM selecionados)
        let baseScale = targetWidthPx / logicalW

        let imgW = logicalW * baseScale * currentZoom
        let imgH = logicalH * baseScale * currentZoom

        // 1. Bloqueia zoom que deixe espaços vazios nas laterais do canvas
        if (imgW < canvas.width) {
          currentZoom = canvas.width / (logicalW * baseScale)
          imgW = canvas.width
        }

        // 2. Bloqueia o Pan (arrasto) para não mostrar o fundo do canvas
        const maxOffsetX = Math.max(0, (imgW - canvas.width) / 2)
        const maxOffsetY = Math.max(0, (imgH - canvas.height) / 2)

        offsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, offsetX))
        offsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, offsetY))
      }

      function renderImageToCanvas(img) {
        if (!img) return
        imagemOriginal = img

        const targetWidthPx = getTargetPx()
        const isVertical = (currentRotation / 90) % 2 !== 0

        // Ativa controles
        ;[
          btnRotate, btnReset, btnCrop, btnArrow,
          btnZoomIn, btnZoomOut, btnZoomReset,
          sliderBrightness, sliderContrast,
          selectArrowColor
        ].forEach((el) => (el.disabled = false))

        // DIMENSÕES DINÂMICAS: Recalcula a altura do canvas baseada na rotação
        let logicalW = isVertical ? img.height : img.width
        let logicalH = isVertical ? img.width : img.height

        // O Canvas assume a largura proporcional aos CM e altura proporcional à imagem rotacionada
        canvas.width = targetWidthPx
        canvas.height = logicalH * (targetWidthPx / logicalW)

        // Ajusta o tamanho do container no ecrã (proporção visual) — mantém seu efeito “menor que a régua”
        canvas.parentElement.style.width = targetWidthPx / 2 + 'px'

        // --- FUNDO BRANCO ---
        ctx.save()
        ctx.fillStyle = '#ffffff'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        ctx.restore()

        applyConstraints()

        ctx.save()

        // Aplica os filtros de imagem
        ctx.filter = `brightness(${sliderBrightness.value}%) contrast(${sliderContrast.value}%)`

        // Aplica Pan e Rotação no centro
        ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY)
        ctx.rotate((currentRotation * Math.PI) / 180)
        ctx.scale(currentZoom, currentZoom)

        // A escala de desenho usa as dimensões ORIGINAIS da imagem
        const drawScale = targetWidthPx / logicalW

        // Desenha a imagem centralizada
        ctx.drawImage(
          img,
          (-img.width * drawScale) / 2,
          (-img.height * drawScale) / 2,
          img.width * drawScale,
          img.height * drawScale
        )

        ctx.restore()

        // cursor
        if (tool === 'crop') canvas.style.cursor = 'crosshair'
        else if (tool === 'arrow') canvas.style.cursor = 'crosshair'
        else canvas.style.cursor = currentZoom > 1.01 ? 'grab' : 'default'
      }

      function toggleTool(nextTool) {
        tool = nextTool

        // reseta estados das ferramentas
        cropDragging = false
        cropRect = null
        arrowDragging = false
        arrowStart = null
        arrowEnd = null

        btnCrop.classList.toggle('active', tool === 'crop')
        btnArrow.classList.toggle('active', tool === 'arrow')

        if (imagemOriginal) renderImageToCanvas(imagemOriginal)
      }

      // --- Overlay Crop (pontilhado) ---
      function drawCropOverlay() {
        if (!cropRect) return
        renderImageToCanvas(imagemOriginal)

        ctx.save()
        ctx.setLineDash([10, 6])
        ctx.lineWidth = Math.max(2, Math.round(canvas.width / 800))
        ctx.strokeStyle = '#111'
        ctx.strokeRect(cropRect.x + 0.5, cropRect.y + 0.5, cropRect.w, cropRect.h)
        ctx.restore()
      }

      // --- Desenho da seta (preview e commit) ---
      function drawArrow(p1, p2, color, width) {
        const dx = p2.x - p1.x
        const dy = p2.y - p1.y
        const angle = Math.atan2(dy, dx)

        // tamanho da cabeça (proporcional)
        const headLen = Math.max(18, Math.round(width * 4.5))

        ctx.save()
        ctx.strokeStyle = color
        ctx.fillStyle = color
        ctx.lineWidth = width
        ctx.lineCap = 'round'
        ctx.lineJoin = 'round'
        ctx.setLineDash([])

        // haste
        ctx.beginPath()
        ctx.moveTo(p1.x, p1.y)
        ctx.lineTo(p2.x, p2.y)
        ctx.stroke()

        // cabeça (triângulo)
        const a1 = angle - Math.PI / 7
        const a2 = angle + Math.PI / 7
        const x1 = p2.x - headLen * Math.cos(a1)
        const y1 = p2.y - headLen * Math.sin(a1)
        const x2 = p2.x - headLen * Math.cos(a2)
        const y2 = p2.y - headLen * Math.sin(a2)

        ctx.beginPath()
        ctx.moveTo(p2.x, p2.y)
        ctx.lineTo(x1, y1)
        ctx.lineTo(x2, y2)
        ctx.closePath()
        ctx.fill()

        ctx.restore()
      }

      function drawArrowOverlay() {
        if (!arrowStart || !arrowEnd) return
        renderImageToCanvas(imagemOriginal)

        const color = selectArrowColor ? selectArrowColor.value : '#111'
        const width = Math.max(4, Math.round(canvas.width / 350)) // espessura simples e responsiva
        drawArrow(arrowStart, arrowEnd, color, width)
      }

      function commitCanvasAsNewBase(cb) {
        const newImg = new Image()
        newImg.onload = () => {
          imagemOriginal = newImg
          currentRotation = 0
          currentZoom = 1.0
          offsetX = 0
          offsetY = 0
          if (typeof cb === 'function') cb()
          renderImageToCanvas(imagemOriginal)
        }
        newImg.src = canvas.toDataURL('image/jpeg', 0.92)
      }

      // --- Largura (cm) ---
      selectWidth.addEventListener('change', () => {
        currentZoom = 1.0
        offsetX = 0
        offsetY = 0
        renderImageToCanvas(imagemOriginal)
      })

      // --- Botões Crop/Arrow ---
      btnCrop.addEventListener('click', () => {
        if (!imagemOriginal) return
        toggleTool(tool === 'crop' ? 'none' : 'crop')
      })

      btnArrow.addEventListener('click', () => {
        if (!imagemOriginal) return
        toggleTool(tool === 'arrow' ? 'none' : 'arrow')
      })

      // --- Mouse down (Crop OU Arrow OU Pan) ---
      canvas.addEventListener('mousedown', (e) => {
        if (!imagemOriginal) return

        // CROP
        if (tool === 'crop') {
          cropDragging = true
          const p = canvasPointFromMouseEvent(e)
          cropStartX = clamp(p.x, 0, canvas.width)
          cropStartY = clamp(p.y, 0, canvas.height)
          cropRect = { x: cropStartX, y: cropStartY, w: 0, h: 0 }
          drawCropOverlay()
          return
        }

        // ARROW
        if (tool === 'arrow') {
          arrowDragging = true
          const p = canvasPointFromMouseEvent(e)
          arrowStart = { x: clamp(p.x, 0, canvas.width), y: clamp(p.y, 0, canvas.height) }
          arrowEnd = { ...arrowStart }
          drawArrowOverlay()
          return
        }

        // PAN (se nenhuma ferramenta ativa)
        if (currentZoom <= 1.01) return
        isDragging = true
        canvas.style.cursor = 'grabbing'
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        startX = e.clientX * scaleX - offsetX
        startY = e.clientY * scaleY - offsetY
      })

      // --- Mouse move (Crop OU Arrow OU Pan) ---
      window.addEventListener('mousemove', (e) => {
        if (!imagemOriginal) return

        // CROP drag
        if (tool === 'crop' && cropDragging) {
          const p = canvasPointFromMouseEvent(e)
          const endX = clamp(p.x, 0, canvas.width)
          const endY = clamp(p.y, 0, canvas.height)

          const x = Math.min(cropStartX, endX)
          const y = Math.min(cropStartY, endY)
          const w = Math.abs(endX - cropStartX)
          const h = Math.abs(endY - cropStartY)

          cropRect = { x, y, w, h }
          drawCropOverlay()
          return
        }

        // ARROW drag
        if (tool === 'arrow' && arrowDragging) {
          const p = canvasPointFromMouseEvent(e)
          arrowEnd = { x: clamp(p.x, 0, canvas.width), y: clamp(p.y, 0, canvas.height) }
          drawArrowOverlay()
          return
        }

        // PAN
        if (!isDragging) return
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        offsetX = e.clientX * scaleX - startX
        offsetY = e.clientY * scaleY - startY
        renderImageToCanvas(imagemOriginal)
      })

      // --- Mouse up (finaliza Crop OU Arrow OU Pan) ---
      window.addEventListener('mouseup', () => {
        // Finaliza CROP
        if (tool === 'crop' && cropDragging) {
          cropDragging = false

          if (!cropRect || cropRect.w < 5 || cropRect.h < 5) {
            cropRect = null
            renderImageToCanvas(imagemOriginal)
            return
          }

          const x = Math.round(cropRect.x)
          const y = Math.round(cropRect.y)
          const w = Math.round(cropRect.w)
          const h = Math.round(cropRect.h)

          const imgData = ctx.getImageData(x, y, w, h)

          // destrutivo: resize do canvas para o recorte
          canvas.width = w
          canvas.height = h

          // fundo branco
          ctx.save()
          ctx.fillStyle = '#ffffff'
          ctx.fillRect(0, 0, w, h)
          ctx.restore()

          ctx.putImageData(imgData, 0, 0)

          // Congela como nova imagem-base
          commitCanvasAsNewBase(() => {
            const suggestedCm = getClosestWidthCm(canvas.width)
            selectWidth.value = suggestedCm.toString()
            toggleTool('none')
          })

          cropRect = null
          return
        }

        // Finaliza ARROW
        if (tool === 'arrow' && arrowDragging) {
          arrowDragging = false

          if (!arrowStart || !arrowEnd) {
            renderImageToCanvas(imagemOriginal)
            return
          }

          const dx = Math.abs(arrowEnd.x - arrowStart.x)
          const dy = Math.abs(arrowEnd.y - arrowStart.y)
          if (dx < 3 && dy < 3) {
            // clique quase parado = cancela
            arrowStart = null
            arrowEnd = null
            renderImageToCanvas(imagemOriginal)
            return
          }

          // “commit” destrutivo: desenha no canvas atual (já está com a imagem renderizada)
          drawArrowOverlay() // garante que o frame atual está correto

          // congela como nova base (zera pan/zoom/rotação porque já “virou pixels”)
          commitCanvasAsNewBase(() => {
            toggleTool('none')
          })

          arrowStart = null
          arrowEnd = null
          return
        }

        // Finaliza PAN
        isDragging = false
      })

      // --- Zoom ---
      btnZoomIn.addEventListener('click', () => {
        currentZoom += 0.2
        renderImageToCanvas(imagemOriginal)
      })
      btnZoomOut.addEventListener('click', () => {
        currentZoom -= 0.2
        renderImageToCanvas(imagemOriginal)
      })
      btnZoomReset.addEventListener('click', () => {
        currentZoom = 1.0
        offsetX = 0
        offsetY = 0
        renderImageToCanvas(imagemOriginal)
      })

      // --- Rotação e Filtros ---
      btnRotate.addEventListener('click', () => {
        currentRotation = (currentRotation + 90) % 360
        currentZoom = 1.0
        offsetX = 0
        offsetY = 0
        renderImageToCanvas(imagemOriginal)
      })
      ;[sliderBrightness, sliderContrast].forEach((s) => {
        s.addEventListener('input', () => renderImageToCanvas(imagemOriginal))
      })

      btnTrigger.addEventListener('click', () => fileInput.click())

      btnReset.addEventListener('click', function () {
        if (imagemOriginal && confirm('Descartar tudo?')) {
          toggleTool('none')
          currentRotation = 0
          currentZoom = 1.0
          offsetX = 0
          offsetY = 0
          selectWidth.value = '14'
          sliderBrightness.value = 100
          sliderContrast.value = 100
          if (selectArrowColor) selectArrowColor.value = '#111111'
          renderImageToCanvas(imagemOriginal)
        }
      })

      fileInput.addEventListener('change', function (e) {
        const file = e.target.files[0]
        if (!file) return
        const reader = new FileReader()
        reader.onload = (ev) => {
          const img = new Image()
          img.onload = () => {
            toggleTool('none')
            currentRotation = 0
            offsetX = 0
            offsetY = 0

            const suggestedCm = getClosestWidthCm(img.width)
            selectWidth.value = suggestedCm.toString()

            const novoWidthPx = Math.round(suggestedCm * 114.2857)
            canvas.width = novoWidthPx

            currentZoom = canvas.width / img.width

            renderImageToCanvas(img)
          }
          img.src = ev.target.result
        }
        reader.readAsDataURL(file)
      })

      // Carregamento inicial da imagem (Modo Edição)
      const initialUrl = editorEl.dataset.initialImageUrl
      if (initialUrl) {
        const img = new Image()
        img.crossOrigin = 'anonymous'
        img.onload = () => {
          {% if object and object.original_width %}
            const savedPx = {{ object.original_width }}
            const targetCm = Math.round(savedPx / 114.2857)
            if ([4, 10, 14].includes(targetCm)) {
              selectWidth.value = targetCm.toString()
            }
          {% endif %}

          toggleTool('none')
          currentRotation = 0
          currentZoom = 1.0
          offsetX = 0
          offsetY = 0

          renderImageToCanvas(img)
        }
        img.src = initialUrl
      }

      // Envio do formulário (Processamento do Canvas para Blob)
      form.addEventListener('submit', function (e) {
        if (!imagemOriginal) return
        e.preventDefault()

        document.getElementById('id_width_override').value = getTargetPx()

        canvas.toBlob(
          (blob) => {
            const file = new File([blob], 'pericia_final.jpg', { type: 'image/jpeg' })
            const dataTransfer = new DataTransfer()
            dataTransfer.items.add(file)
            fileInput.files = dataTransfer.files

            form.submit()
          },
          'image/jpeg',
          0.92
        )
      })
    })
  </script>
{% endblock %}

